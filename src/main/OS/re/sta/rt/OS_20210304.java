package re.sta.rt;

public class OS_20210304 {

    /*  프로세스와 스케쥴러의 이해 ( INTERRUPT 인터럽트 )

어떻게?
    I.O device가 파일 읽기가 끝났을 때? CPU가 block 상태에서  ready상태로 옮겨져 running 상태로 될까?

인터럽트란? -EVENT?
    CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치(EVENT 발생)나 또는 예외상황이 발생하여
    처리가 필요할 경우에 CPU에 알려서 처리하는 기술.

인터럽트가 필요한 이유?
    선점형 스케쥴러 구현
        프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스를 실행을 중단시킴
            - 그러려면, 스케쥴러  코드가 실행이 되서, 현 프로세스 실행을 중지시켜야함

    ready --> running --> waiting(I/O or event wait) --> ready(I/O or event completion)
                      --> interrupt                  --> interrupt
                      --> terminated(exit)

인터럽트가 필요한 이유-2?
    예외 상황 핸들링
        CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우,
        CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함.

        EX) 1/0 계산 <- CPU. 이러한 예외상황의 CPU 구동을 KILL 시켜주어야 함.

     */



    /*  프로세스와 스케쥴러의 이해 ( INTERRUPT 인터럽트 종류 )

지난시간 정리 : CPU는 code 1줄(pc)를 처리 중에, 중요한 처리가 필요할 시 interrupt 가 들어올 수 있습니다.
인터럽트 처리 Ex?
    CPU가 프로그램을 실행하고 있을 때,
        입출력 하드웨어 등의 장치 이슈 발생
            - 파일 처리가 끝났다는 것을 운영체제에 알려주기
            - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready)상태로 프로세스 상태 변경하기

        또는 예외 상황이 발생
            - 0으로 나누는 계산이 발생해서, 예외 발생을 운영체제에 알려주기
            - 운영체제가 해당 프로세스 실행 중지/ 에러 표시


종류?
1. 주요 인터럽트
    1/0 과 같은 코드상의 예외상황
2. 타이머 인터럽트
    선점형 스케줄러를 위해 필요
        하드웨어로 부터 일정 시간마다 타이머 인터럽터를 운영체제에 알려줍니다.
3. 입출력(I/O) 인터럽트
    프린터, 키보드 , 마우스, 저장매체(SSD 등)


내외부 인터럽트 나누기?
    내부 인터럽트(소프트웨어 인트럽트)
        주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용 시 발생
            - 0 으로 나눴을 때
            - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근 시
            - 계산 결과가 Overflow / Underflow 날 때
    외부 인터럽트(하드웨어 인터럽트)
        주로 하드웨어에서 발생되는 이벤트 ( 프로그램 외부 )
            - 전원 이상
            - 기계 문제
            - 키보드 등 I/O 관련 이벤트
            - Timer 이벤트
     */


    /*  프로세스와 스케쥴러의 이해 ( INTERRUPT 인터럽트 내부 동작 )

시스템 콜 인터럽트?
    시스템 콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.
    시스템 콜 실제 코드
        - eax 레지스터에 시스템 콜 번호를 넣고,
        - ebx 레지스터에 시스템 콜에 해당하는 인자값을 넣고,
        - 소프트웨어에 인터럽트 명령을 호출하면서 0x80값을 넘겨 줌

            mov eax , 1 (시스템 콜 번호)
            mov ebx , 0 (인자)
            int 0x89  (소프트웨어 인터럽트 명령)  * int는 <op code>,  0x80는 <시스템 콜 명령 값>
                intel사는 integer(int)를 사용

인터럽트와 시스템 콜 (고급)?
    시스템 콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
        1. CPU는 사용자 모드를 커널모드로 바꿔줌
        2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행
        3. system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
            * 시스템 콜 내에 시스템 번호(eax)에 맡게 각각의 함수가 있다.
        4. 해당 시스템콜 함수 실행 후, 다시 커널모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행
            * 시스템 콜 내에 있는 각각의 함수가 커널모드에서 실행이 된다.

사용자/커널 모드와 프로세스, 인터럽트?

    User Mode   :   Process A ->                       Process A ->                      Process B
---------------------------------------------------------------------------------------------------->
    Kernel Mode :                SystemCall Handler ->              Process Scheduler ->
                                ↓(system call)                     ↓(timer event)



인터럽트와 IDT?
    인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
        - 어디에? IDT에 기록
        - 언제? 컴퓨터 부팅 시 운영체제가 기록 (이벤트 번호 : 실행 코드의 주소)
        - 어떤 코드에? 운영체제 내부 코드


정리.
    항상 인터럽트 발생 시, IDT를 확인
    시스템 콜 인터럽트 명령은 0x80 번호가 미리 정의
    인터럽트  0x80에 해당하는 운영체제 코드는 system_call() 이라는 함수
    즉, IDT에는 0x80 -> system_call()와 같은 정보가 기록되어 있음.


인터럽트와 IDT?
    리눅스 경우?
        - 0~31 : 예외상황(내부/소프트웨어) 인터럽트 (일부는 정의안된 채로 남겨져 있음)
        - 32~47 : 하드웨어(외부/하드웨어) 인터럽트 (주변장치 종류/ 갯수에 따라 변경 가능)
        - 128(Ox80를 10진수) : 시스템 콜


인터럽트와 프로세스?
    1. 프로세스 실행 중 인터럽트 발생
    2. 현 프로세스 실행 중단
    3. 인터럽트 처리 함수 실행(운영체제)
    4. 현 프로세스 재 실행

        User Mode   :   Process A ->                                    Process A ->
------------------------------------------------------------------------------------->
        Kernel Mode :                <----------> SystemCall Handler ->
                                      ↓ Process A 중단(현 상태 저장)
                                        Interrupt 번호에 해당하는 함수 호출출


     */

    /*  프로세스와 스케쥴러의 이해 ( 프로세스 구조 )

서문:
프로세스와 컨텍스트 스위칭
    프로세스 구조 deep dive -> Process A와 Process B를 바꿔주는 것이 스위칭이라고 한다.

    STATCK은 함수의 공간
    HEAP은 동적으로 할당하는 메모리 공간
    DATA는 이미 정해져 있는 값이 정해진(선언된) 것들의 공간
    CODE는 Program이 실행하여 컴파일되면? 이 공간에 들어간다.

     */




}
