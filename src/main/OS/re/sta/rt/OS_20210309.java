package re.sta.rt;


    /*
        가상 메모리

실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음.
    - 리눅스는 하나의 프로세스가 4g임.
    - 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야함.


가상 메모리 : 메모리는 실제 메모리보다 많아 보이게하는 기술
    실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
    프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음.
    프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다.
        - virtual address(가상 주소) : 프로세스가 참조하는 주소
        - physical address(물리 주소) : 실제 메모리 주소
    MMU(Memory Management Unit)
        CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주고 값으로 변환해주는 하드웨어 장치

                CPU  -------> MMU -------> Memory
                     Virtual       Physical
                     address       address

페이징 시스템 메커니즘
    페이징 개념 :
        - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
        - 하드웨어 지원 필요
            * 예) Intel x86에서는 4KB, 2KB, 1GB 지원
        - 리눅스에서는 4KB로 paging
        - 페이지 번호를 기반으로 가상 주소/물리 주소로 매핑 기록/사용

페이징 시스템 구조
    page 또는 page frame : 고정된 크기의 block (4KB)
    paging system
        - 가상 주소 v = (p,d)
            p : 가상 메모리 페이지
            d : p안에 참조하는 위치(변위)

페이지 테이블 (page table)
    page table
        - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
        - 가상 주소 v = (p,d) 라면
            p : 페이지 번호
            d : 페이지 처음부터 얼마 떨어진 위치인지

    page system 동작
        - 해당 프로세스에서 특정 가상 주소 엑세스를 하려면?
            해당 프로세스의 page table 에 해당 가상 주소가 포함된 page 번호가 있는지 확인
            page 번호가 있으면 이 page 가 매핑된 첫 물리 주소를 알아내고 (p')
            p' + d 가 실제 물리주소가 됨

다중 단계 페이징 시스템
    32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은
        - 하위 12bit 는 오프셋
        - 상위 20bit 가 페이징 번호이므로 2의 20(1048576)개의 페이지 정보가 필요함.


    페이징 정보를 단계를 나누어 생성
        - 필요없는 페이지는 생성하지 않으면, 공간 절약 가능

            CR3 레지스터 ----> Page Directory ----> Page Table ----> Physical Frame
                                    10bit             10bit             12bit

MMU와 TLB(컴퓨터구조)
    TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬

           CPU -------> MMU -------> Memory -------> MMU -------> Memory -------> CPU
               Virtual         CR3          Physical      Physical        Data전달
              address        Register       address        address
                 요청                           전달           접근


           CPU -------> MMU -------> Memory -------> CPU
                  * TLB를 잠깐 들림


페이징 시스템과 공유 메모리
    프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 모메리 할당시간 절약)


요구 페이징?
    프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
        - 선행 페이징의 반대 개념 :
                    선행 페이지는 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
        - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)


페이지 폴트 (page fault)
    어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
    운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모링레 올림


페이지 교체 정책
    운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?
        - 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
        - 새로운 페이지를 해당 물리 메모리 공간에 올린다.

페이지 교체 알고리즘(FIFO) : 가장 먼저 들어간 녀석(page)을 내린다.
페이지 교체 알고리즘(OPT)  : 가장 뒤로 안 쓸만한 것(page)을 내린다.
페이지 교체 알고리즘(LRU)  : 가장 오래 전에 사용한 것(page)을 내린다.
페이지 교체 알고리즘(LFU)  : 가장 적게 사용된 것(page)을 내린다.
페이지 교체 알고리즘(NUR)  : 각 페이지마다, 읽었는지(read)? 썼는지(write)?를 정보 유지를하여
                            0,0 -> 0,1 -> 1,0 -> 1,1 순으로 교체

스레싱(Thrashing)
    반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황
        프로그램을 많이 띄어놓으면, cpu가 프로그램을 실행하다가,
        어느 순간 급격히 cpu사용률이 떨어지는 경우가 있다. 그 땐 page스왑, page폴트만 일어나는 현상.

세그멘테이션(Segmentation) 기법
    가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼로 분할


참고.
    내부 단편화 (페이지 기법)
        - 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비

    외부 단편화 (세그멘테이션 기법)
        - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우

    세그멘테이션/페이징 모두 하드웨어 지원필요
        - 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현


    */





    /*

        파일 시스템의 이해

파일 시스템이란?
    운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘

파일 시스템이 만들어진 이유(블록) ?
    저장매체는 0과 1의 데이터를 저장하였습니다.
        그런데?
            비트단위로 관리하기가 오버헤드가 너무 큼.
                그게 무리라?
                    블록 단위로 관리하기로 함 (보통 4KB)
                        그런데..
                            사용자가 각 블록 고유번호를 관리하기가 어려움.
                                따라서,
                                    추상적(논리적) 객체필요 : 파일
                                        사용자는 파일단위로 관리
                                            파일 안에서 내부적으로 관리하는 것은 블록단위로 관리.

    저장 매체에 효율적으로 파일을 저장하는 방법.
        - 가능한 연속적인 공간을 파일로 저장하는 것이 좋다고 생각하였음.
        - 하지만, 외부 단편화, 파일 사이즈 변경 문제로 불연속 공간에 파일 저장 기능 지원이 필요하다 생각하였음.
             * 블록체인 : 블록을 링크드 리스트로 연결
             * 인덱스 블록 기법 : 각 블록에 대한 위치 정보를 기록해서, 한 번에 끝 블록을 찾아갈 수 있도록 함.


Inode 방식 파일 시스템.
    파일 시스템 기본 구조
        - 수퍼블록 : 파일 시스템 정보 & 파티션 정보
        - 아이노드 블록 : 파일 상세 정보
        - 데이터 블록 : 실제 데이터


Inode와 파일
    파일 : inode 고유값과 자료구조에 의해 주요 정보 관리
        - '파일이름:inode' 로 파일 이름은 inode 번호와 매칭
        - 파일 시스템에서는 inode를 기반으로 파일 엑세스
        - inode 기반 메타 데이터 저장
            예시) 프로세스 생성 -> ProcessID -> PCB  <------- 스케쥴링 등 여러작읍
                     파일 생성 -> Inode번호 -> inode블록 <------- 파일처리


Inode 구조
    inode 기반 메타 데이터(파일권한, 소유자 정보, 파일사이즈, 생성시간 등 시간 관련정보, 데이터 저장 위치등)


디렉토리 엔트리
    리눅스 파일 탐색 예-/home/ubuntu/ink.txt
        i. 각 디렉토리 엔트리를 검색
            각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있음
       ii. '/' dentry에서 'home'을 찾고 'home'에서 'ubuntu'를 찾고.......


가상 파일 시스템 (Virtual File System)
    Network 등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 가능
    예: read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)


참고 : 특수파일
    디바이스
        - 블록 디바이스
        : HDD,CD/DVD 와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음
        - 캐릭터 디바이스
        : 키보드, 마우스 등 Byte 단위 데이터 전송, IO 송수신 속도가 낮음

내부적으로 디바이스를 이렇게 사용한다. ↑













     */



public class OS_20210309 {
}
