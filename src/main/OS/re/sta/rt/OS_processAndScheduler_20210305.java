package re.sta.rt;

    /*  프로세스와 스케쥴러의 이해 (프로세스 구조와 컴퓨터 구조)

프로세스는 일반적으로 어떻게 구성되어 있을까?
    text(CODE) : 코드
    data : 변수/초기화된 데이터
    stack(stack frame) : 임시 데이터 (함수 호출, 로컬 변소 등)
    heap : 코드에 동적으로 만들어지는 데이터

PC(Program Counter) + Stack Pointer

    PC가 CODE 부분을 읽으면서 PC가 가지고있는 주소값이 변경됨에 따라, STACK 부분에서는
    첫 번째는 EBP가 가지고있는 STACK Pointer 주소
    두 번째는 함수의 결과 값
    세 번째는 함수의 매개변수로 들어가는 인자 값
    ...
    마지막은 EBP가 가지고 있는 STACK Pointer 주소
        *EBP 레지스터란? 함수가 가지고있는 최상,최하단 값을 스택에 줌.
            함수가 안에서 문제가 있을 때, 어떤 부분이 문제가 있는 지 빠르게 트레킹 할 수 있다.


Heap 이란?
    실행코드 안에서 어떻게 변하는 지를 모르며 동적으로 할당에서 사용할지 모르니, 동적으로 사용한다.

DATA 란?
    BSS  -> 초기화 되지 않은 전역변수
    DATA -> 초기값이 있는 전역변수
     */



    /*  프로세스와 스케쥴러의 이해 (프로세스 구조와 컨텍스트 스위칭)

PCB(Process Control Block)?
프로세스의 상태를 저장하는 구조로 운영체제에서 관리를 하고있다.
    1. Process ID
    2. Register 값 (PC ,SP 등)
    3. Scheduling Info (Process State)
    4. Memory Info (메모리 사이즈 limit


Context Switching (문맥 교환)
    CPU에 실행할 프로세스를 교체하는 기술
        1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
        2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보를 CPU에 넣고, 실행


                      PCB 정보를 저장             PCB 정보를 로드
                            ↑                         ↓
               processA ---------context switching--------> processB
     *컨텍스트 스위칭은 실행하기 위한 실행 코드가 존재하다. (리눅스 같은 경우는 어셈블리어로 작성된다)
                        *PCB정보(PC,SP)를 CPU의 레지스터에 넣는다.

    디스패치(dispatch) : ready 상태의 프로세스를 running 상태로 바꾸는 것
     */


    /*  프로세스와 스케쥴러의 이해 (프로세스 간 커뮤니케이션)

IPC(InterProcess Communication) -> 커널공간을 활용하는 것이라고 생각.
        프로세스 간 통신 방법을 제공함
        IPC : FILE 사용-> file을 사용하면, 실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움.
                    why? 해당 프로세스가 파일을 읽어야하는데, 계쏙 실시간으로 읽고만 읽을 수는 없으니...

프로세스간 통신이 필요할까요?
    성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행
    이 때 프로세스 간 상태 확인 및 데이터 송수신이 필요

IPC 다양한 기법
    1. file 사용
    (↓ 커널공간의 메모리를 사용하고 공유 하는 기법들)
    2. Message Queue : 큐니까, 기본은 FIFO 정책으로 데이터 전송
                       메세지를 넣으면 넣은 순서대로 메시지를 뺄 수 있다.
    3. Shared Memory : 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
                       공유 메모리 key를 가지고, 여러 프로세스가 접근 가능
    4. Pipe : 기본 파이프는 단방향 통신
              fork()로 자식 프로세스를 만들었을 때, 부모와 자식간의 통신
    5. Signal : 유닉스에서 30년 이상 사용된 전통적인 기법
                커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는 지를 알려주는 기법
                 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
                    *시그널 무시 -> 시그널 블록 -> 등록된 시그널 핸들러로 특정동작 수행
                                            -> 등록된 시그널 핸들러가 없다면, 커널에서 기본동작 수행

                SIGKLL
                SIGALARM
                SIGSTP
                SIGCONT
                SIGINT
                SIGSEGV

                커널모드-> 사용자모드로 전환시 시그널 처리를 합니다 (깊은 내용)

    6. Semaphore
    7. Socket : 소켓은 네트워크 통신을 위한 기술
                기본적으로는 클라이언트와 서버등 두 개의 다른 컴퓨터간의 네트워키 기반 통신을 위한 기술술
    ....
     */


















public class OS_processAndScheduler_20210305 {

}
