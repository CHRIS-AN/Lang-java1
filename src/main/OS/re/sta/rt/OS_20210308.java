package re.sta.rt;

 /*
        Thread(스레드)

스레드란?
    Light Weight Process 라고도 함.
    프로세스
        프로세스 간에는 각 프로세스의 데이터 접근이 불가. (IPC)
    스레드
        하나의 프로세스에 여러 개의 스레드 생성 가능
        스레들은 동시에 실행 가능
        프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능. (IPC 불가)


Thread는 각기 실행이 가능한 stack이 존재?
    registers, stack이 따로 존재한다.


멀티태스킹 vs 멀티프로세스 vs Thread ?

멀티태스팅 :
cpu가 한 개가 있고, 여러개의 프로세스가 있는  걸 약100ms를 기준으로 번갈아 가며 실행을하여, 동시에 실행하는 것처럼 보이기 위함.
멀티프로세스 :
하나의 process를 여러 개의 cpu를 사용을 하여 병렬 실행으로 실행 속도를 올리는 것
Thread :
하나의 process 안에 여러 개의 thread가 존재하고, 여러 개의 cpu를 사용하여, 병렬 실행


Thread 장단점?
    장점 : 1. 사용자에 대한 응답성 향상
          2. 자원 공유 효율
                - IPC 기법과 같이 프로세스 간 자원 공유를 위해 번거로운 작업이 필요 없음
                - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
                - 작업이 분리되어 코드가 간결 (사실 작성하기 나름)

    단점: 1. 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음 (멀티프로세스<O> VS 멀티스레드<X>)
         2. Thread를 많이 생성하면, Context Switching이 많이 일어나, 성능 저하
                - 스레드를 많이 생성하면, 모든 스레드를 스케쥴링해야 하므로, 복잡도 증가


Thread VS Process?
    프로세스는 독립적, 스레드는 프로세스의 서브셋
    프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원공유
    프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유
    프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요없음


Thread 동기화(Synchronization) 이슈
    동기화 : 작업들 사이에 실행 시기를 맞추는 것
    여러 스레드가 동일한 자원(데이터) 접근 시 동기화 이슈 발생
        동일한 자원을 여러 스레드가 동시 수정 시, 각 스레드 결과에 영향을 줌

Thread 이슈 해결 방안.
    Mutual exclusion (상호배제)
    스레드는 프로세스 모든 데이터를 접근할 수 있으므로,
        여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요.
        어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막음.

Mutual exclusion(상호배제)
    임계 자원(critical resource)
    임계 영역(critical section)



Mutex와 세마포어(Semaphore)
    임계구역(critical section)에 대한 접근을 막기 위해 Locking 메커니즘 (상호배제)이 필요

        <2가지의 locking 메커니즘>
        Mutex(binary semaphore)
        : 임계 구역에 하나의 스레드만 들어갈 수 있음.
        Semaphore
        : 임계 구역에 여러 스레드가 들어갈 수 있음
        : counter를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레두 수를 제어


Semaphore 기법?
    P : 검사(임계 영역에 들어갈 때)
    V : 증가(임계 영역에 나올 때)
    S : 세마포어 값(초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)

Thread 교착상태(Deadlock)?
    무한 대기 상태 : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에,
                    다음 단계로 진행하지 못하는 상태.

                   Thread1 ----> Resource1 ----> Thread2 ----> Resource2 ----> Thread1(원점)
                           (lock)          (wait)        (lock)          (wait)
                   * 배치 처리 시스템에서는 일어나지 않는 문제
    참고: 네 가지 조건이 모두 성립될 때, 교착 상태가 발생 가능성이 있음
        1. 상호배제
        2. 점유대기
        3. 비선점
        4. 순환대기

Thread 기아상태(Starvation)?
    특정 프로세스가 우선순위가 낮아서 원하는 자원을 할당 받지 못하는 상태
    교창 상태와 기아 상태 차이
        - 교착상태 여러 프로세스가 동일 자원 점유를 요청할 때, 발생
        - 기아상태 여러 프로세스가  부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이
          안되는 경우를 주로 의미함.

기아 상태 해결방안?
    우선 순위를 변경
        - 수시로 변경.
        - 오래 기다린 프로세스의 우선순위 높여주기
        - 우선 순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용



  */



public class OS_20210308 {
}

